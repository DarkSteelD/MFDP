"""
Module: routes.prediction

Contains endpoints for ML prediction operations.
"""

from typing import List, Any, Dict, Optional
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File
from sqlalchemy.orm import Session
import os
import json
import shutil
from pathlib import Path
from aio_pika import connect_robust, Message

from src.schemas.prediction import PredictionRequest, PredictionResponse, Scan3DRequest, Scan3DResponse, DataValidationError
from src.dependencies import get_db, get_current_active_user
from src.db.models import User as DBUser, Transaction

router = APIRouter(prefix="/predict", tags=["prediction"])

RABBITMQ_URL = os.getenv("RABBITMQ_URL", "amqp://guest:guest@rabbitmq/")
IMAGE_QUEUE = os.getenv("IMAGE_QUEUE", "image_tasks")
SCAN3D_QUEUE = os.getenv("SCAN3D_QUEUE", "scan3d_tasks")
RESULTS_QUEUE = os.getenv("RESULTS_QUEUE", "results")

# Create uploads directory if it doesn't exist
UPLOADS_DIR = Path("uploads")
UPLOADS_DIR.mkdir(exist_ok=True)

@router.post("/", response_model=PredictionResponse)
async def predict(
    request: PredictionRequest,
    db: Session = Depends(get_db),
    current_user: DBUser = Depends(get_current_active_user)
):
    """
    Submit text or image data for ML predictions and charge user credits.

    Steps:
      1. Authenticate and ensure user is active via dependency injection.
      2. Validate that exactly one of 'text' or 'image' is provided (Pydantic schema enforces this).
      3. Verify current_user.balance is positive; raise HTTPException 400 if insufficient funds.
      4. Perform ML prediction on the provided input:
         - If 'text' provided, pass text to text-based model.
         - If 'image' provided, decode base64 and pass image to vision model.
      5. Calculate credits_spent based on the size of input or number of predictions.
      6. Deduct credits_spent from current_user.balance and create a 'prediction' transaction.
      7. Commit all database changes.
      8. Return a PredictionResponse with the appropriate prediction field and credits_spent.

    Args:
      request (PredictionRequest): contains either 'text' or 'image' field.
      db (Session): database session provided by dependency.
      current_user (User): authenticated and active user instance.

    Returns:
      PredictionResponse: contains 'text_prediction' or 'image_prediction' and credits_spent.

    Raises:
      HTTPException: 401 if user is not authenticated.
      HTTPException: 403 if user is inactive.
      HTTPException: 400 if user has insufficient balance.
    """
    # Ensure positive balance
    if current_user.balance <= 0:
        raise HTTPException(status_code=400, detail="Insufficient balance")
    # Charge fixed credits for prediction
    credits_spent = 50.0
    # Create a 'prediction' transaction record
    transaction = Transaction(
        user_id=current_user.id,
        type="prediction",
        amount=credits_spent
    )
    db.add(transaction)
    # Deduct balance
    current_user.balance -= credits_spent
    db.add(current_user)
    db.commit()
    # Publish task to RabbitMQ
    body = json.dumps({
        "transaction_id": transaction.id,
        "image": request.image
    }).encode()
    connection = await connect_robust(RABBITMQ_URL)
    channel = await connection.channel()
    await channel.declare_queue(IMAGE_QUEUE, durable=True)
    await channel.default_exchange.publish(
        Message(body=body),
        routing_key=IMAGE_QUEUE
    )
    await connection.close()
    
    # For now, return mock mask URL (in real implementation, this would be generated by the worker)
    mask_url = f"/downloads/mask_{current_user.id}_image.png"
    
    return PredictionResponse(
        text_prediction=None,
        image_prediction=mask_url,
        credits_spent=credits_spent
    )


@router.post("/3d-scan", response_model=Scan3DResponse)
async def predict_3d_scan(
    scan: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: DBUser = Depends(get_current_active_user)
):
    """
    Submit 3D medical scan for analysis and charge user credits.
    
    Args:
      scan (UploadFile): 3D scan file in NIfTI format
      db (Session): database session provided by dependency
      current_user (User): authenticated and active user instance
      
    Returns:
      Scan3DResponse: contains URLs to download brain and aneurysm masks
      
    Raises:
      HTTPException: 400 if file format is invalid or insufficient balance
      HTTPException: 401 if user is not authenticated
      HTTPException: 403 if user is inactive
    """
    # Validate file format
    if not scan.filename.endswith(('.nii', '.nii.gz')):
        raise HTTPException(
            status_code=400, 
            detail="Invalid file format. Please upload a NIfTI file (.nii or .nii.gz)"
        )
    
    # Ensure positive balance
    if current_user.balance <= 0:
        raise HTTPException(status_code=400, detail="Insufficient balance")
    
    # Charge fixed credits for 3D scan analysis
    credits_spent = 100.0
    
    # Save uploaded file
    file_path = UPLOADS_DIR / f"{current_user.id}_{scan.filename}"
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(scan.file, buffer)
    
    # Create a 'scan3d' transaction record
    transaction = Transaction(
        user_id=current_user.id,
        type="scan3d",
        amount=credits_spent
    )
    db.add(transaction)
    
    # Deduct balance
    current_user.balance -= credits_spent
    db.add(current_user)
    db.commit()
    
    # Publish task to RabbitMQ
    body = json.dumps({
        "transaction_id": transaction.id,
        "scan_path": str(file_path),
        "user_id": current_user.id,
        "filename": scan.filename
    }).encode()
    
    connection = await connect_robust(RABBITMQ_URL)
    channel = await connection.channel()
    await channel.declare_queue(SCAN3D_QUEUE, durable=True)
    await channel.default_exchange.publish(
        Message(body=body),
        routing_key=SCAN3D_QUEUE
    )
    await connection.close()
    
    # For now, return mock URLs (in real implementation, these would be generated by the worker)
    brain_mask_url = f"/downloads/brain_mask_{current_user.id}_{scan.filename}"
    aneurysm_mask_url = f"/downloads/aneurysm_mask_{current_user.id}_{scan.filename}"
    original_scan_url = f"{current_user.id}_{scan.filename}"
    
    return Scan3DResponse(
        brain_mask_url=brain_mask_url,
        aneurysm_mask_url=aneurysm_mask_url,
        original_scan_url=original_scan_url,
        credits_spent=credits_spent
    )